<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>dtn7-esp: dtn7-esp/include/Misc/helpers.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">dtn7-esp
   </div>
   <div id="projectbrief">An implementation of the Bundle Protocol Version 7 (RFC9171) for ESP32 microcontrollers using the ESP-IDF</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_a70891491c3d81934661c8a81c427370.html">dtn7-esp</a></li><li class="navelem"><a class="el" href="dir_2f82ac09b2e4c266c2c2eb9282a5f5b2.html">include</a></li><li class="navelem"><a class="el" href="dir_f75aa80d17e235e422675d92dc5f6850.html">Misc</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">helpers.h File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Provides helpers used for serializing <a class="el" href="classBundleInfo.html" title="this class stores additional info to bundles and the corresponding Bundle">BundleInfo</a> and <a class="el" href="classNode.html" title="This class represents a DTN node.">Node</a>, a Hash function wrapper Class used if BPoL with BundleID hashes in advertisements is enabled.  
<a href="#details">More...</a></p>

<p><a href="helpers_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHashWrapper.html">HashWrapper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">base class for different hash functions to use in BPoL advertisements, to use a custom hash function a Class derived from this one must be provided and instantiated in dtn7-espsetupClasses  <a href="classHashWrapper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStdHasher.html">StdHasher</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This Class is just a Wrapper around std::hash.  <a href="classStdHasher.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ae622e76ceddf80a00f7a43e3dc3cf1da" id="r_ae622e76ceddf80a00f7a43e3dc3cf1da"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="helpers_8h.html#ae622e76ceddf80a00f7a43e3dc3cf1da">stringFromCbor</a> (CborValue *value)</td></tr>
<tr class="memdesc:ae622e76ceddf80a00f7a43e3dc3cf1da"><td class="mdescLeft">&#160;</td><td class="mdescRight">reads an std::string from a CborValue containing a CBOR Text string. The given CborValue is advanced to the next element after the String  <br /></td></tr>
<tr class="separator:ae622e76ceddf80a00f7a43e3dc3cf1da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5e3f91aee3af75bf5ea5225f95814f0" id="r_ae5e3f91aee3af75bf5ea5225f95814f0"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structEID.html">EID</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="helpers_8h.html#ae5e3f91aee3af75bf5ea5225f95814f0">decodeEidArray</a> (CborValue *value)</td></tr>
<tr class="memdesc:ae5e3f91aee3af75bf5ea5225f95814f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">reads an array of EIDs from a CBOR value, if it contains an array of EIDs in their standard CBOR encoding. Such an array can be created with encodeEidArray. The given CborValue is advanced to the next element after the Array of EIDs.  <br /></td></tr>
<tr class="separator:ae5e3f91aee3af75bf5ea5225f95814f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39262bc3dc1bd972a7cbdb5e6c2e08d6" id="r_a39262bc3dc1bd972a7cbdb5e6c2e08d6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="helpers_8h.html#a39262bc3dc1bd972a7cbdb5e6c2e08d6">stringToCbor</a> (CborEncoder *encoder, std::string toEncode)</td></tr>
<tr class="memdesc:a39262bc3dc1bd972a7cbdb5e6c2e08d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">encodes a given std::string onto a given CBOR Encoder  <br /></td></tr>
<tr class="separator:a39262bc3dc1bd972a7cbdb5e6c2e08d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac260466aacbabdadd5dc2b8c92360b12" id="r_ac260466aacbabdadd5dc2b8c92360b12"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="helpers_8h.html#ac260466aacbabdadd5dc2b8c92360b12">encodeEidArray</a> (CborEncoder *encoder, std::vector&lt; <a class="el" href="structEID.html">EID</a> &gt; &amp;Eids)</td></tr>
<tr class="memdesc:ac260466aacbabdadd5dc2b8c92360b12"><td class="mdescLeft">&#160;</td><td class="mdescRight">encodes all EIDs contained in the given vector into an CBOR array on the given CBOR Encoder, the CBOR encoding of the individual EIDs is as described in RFC9171. The resulting array can be decoded with decodeEidArray.  <br /></td></tr>
<tr class="separator:ac260466aacbabdadd5dc2b8c92360b12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92ccd75e1f847363ec21ee8ba5ca8fae" id="r_a92ccd75e1f847363ec21ee8ba5ca8fae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="helpers_8h.html#a92ccd75e1f847363ec21ee8ba5ca8fae">encodeNodeArray</a> (CborEncoder *encoder, std::vector&lt; <a class="el" href="classNode.html">Node</a> &gt; &amp;nodes)</td></tr>
<tr class="memdesc:a92ccd75e1f847363ec21ee8ba5ca8fae"><td class="mdescLeft">&#160;</td><td class="mdescRight">encode all Nodes of the given <a class="el" href="classNode.html" title="This class represents a DTN node.">Node</a> Vector into a CBOR array of Byte Strings, the byte strings are equivalent to the CBOR encoding of the node object. The resulting CBOR can be decoded with decodeNodeArray.  <br /></td></tr>
<tr class="separator:a92ccd75e1f847363ec21ee8ba5ca8fae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4968f4b81f900f158f9b27c330da8590" id="r_a4968f4b81f900f158f9b27c330da8590"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classNode.html">Node</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="helpers_8h.html#a4968f4b81f900f158f9b27c330da8590">decodeNodeArray</a> (CborValue *value)</td></tr>
<tr class="memdesc:a4968f4b81f900f158f9b27c330da8590"><td class="mdescLeft">&#160;</td><td class="mdescRight">reads an array of Nodes from a CBOR value, if it contains a CBOR array of byte strings, as created by encodeNodeArray. The Stored nodes are returned in a vector. The given CborValue is advanced to the next element after the Array of Nodes.  <br /></td></tr>
<tr class="separator:a4968f4b81f900f158f9b27c330da8590"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addbe47bad3434e49a9eff95d45eeff30" id="r_addbe47bad3434e49a9eff95d45eeff30"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="helpers_8h.html#addbe47bad3434e49a9eff95d45eeff30">encodeBundle</a> (CborEncoder *encoder, <a class="el" href="classBundle.html">Bundle</a> *bundle)</td></tr>
<tr class="memdesc:addbe47bad3434e49a9eff95d45eeff30"><td class="mdescLeft">&#160;</td><td class="mdescRight">encodes the given <a class="el" href="classBundle.html" title="Representation of a DTN7 bundle in accordance to RFC9171.">Bundle</a> into a CBOR Byte String, the byte string is equivalent to the CBOR encoding of the <a class="el" href="classBundle.html" title="Representation of a DTN7 bundle in accordance to RFC9171.">Bundle</a>, as described in RFC9171. Can be decoded using decodeBundle.  <br /></td></tr>
<tr class="separator:addbe47bad3434e49a9eff95d45eeff30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac13a512800ee8ba47a3cc789d8761f6a" id="r_ac13a512800ee8ba47a3cc789d8761f6a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBundle.html">Bundle</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="helpers_8h.html#ac13a512800ee8ba47a3cc789d8761f6a">decodeBundle</a> (CborValue *value)</td></tr>
<tr class="memdesc:ac13a512800ee8ba47a3cc789d8761f6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">decodes a <a class="el" href="classBundle.html" title="Representation of a DTN7 bundle in accordance to RFC9171.">Bundle</a> from a CBOR Byte String pointed to by the given CborValue, as created by encodeBundle.  <br /></td></tr>
<tr class="separator:ac13a512800ee8ba47a3cc789d8761f6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbbe2b2dfcf7d35e10c7a3c9f9620e53" id="r_adbbe2b2dfcf7d35e10c7a3c9f9620e53"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="helpers_8h.html#adbbe2b2dfcf7d35e10c7a3c9f9620e53">encodeHashesSet</a> (CborEncoder *encoder, std::set&lt; size_t &gt; &amp;hashes)</td></tr>
<tr class="memdesc:adbbe2b2dfcf7d35e10c7a3c9f9620e53"><td class="mdescLeft">&#160;</td><td class="mdescRight">encodes a set of Hashes into a CBOR Array, can be decoded using decodeHashesSet.  <br /></td></tr>
<tr class="separator:adbbe2b2dfcf7d35e10c7a3c9f9620e53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6d1d044de56caec6251027e885bd941" id="r_ab6d1d044de56caec6251027e885bd941"><td class="memItemLeft" align="right" valign="top">std::set&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="helpers_8h.html#ab6d1d044de56caec6251027e885bd941">decodeHashesSet</a> (CborValue *value)</td></tr>
<tr class="memdesc:ab6d1d044de56caec6251027e885bd941"><td class="mdescLeft">&#160;</td><td class="mdescRight">decodes a set of Hashes from CBOR Array pointed to by the given CborValue. Such a CBOR array can be created using encodeHashesSet.  <br /></td></tr>
<tr class="separator:ab6d1d044de56caec6251027e885bd941"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Provides helpers used for serializing <a class="el" href="classBundleInfo.html" title="this class stores additional info to bundles and the corresponding Bundle">BundleInfo</a> and <a class="el" href="classNode.html" title="This class represents a DTN node.">Node</a>, a Hash function wrapper Class used if BPoL with BundleID hashes in advertisements is enabled. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="ac13a512800ee8ba47a3cc789d8761f6a" name="ac13a512800ee8ba47a3cc789d8761f6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac13a512800ee8ba47a3cc789d8761f6a">&#9670;&#160;</a></span>decodeBundle()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBundle.html">Bundle</a> * decodeBundle </td>
          <td>(</td>
          <td class="paramtype">CborValue *&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>decodes a <a class="el" href="classBundle.html" title="Representation of a DTN7 bundle in accordance to RFC9171.">Bundle</a> from a CBOR Byte String pointed to by the given CborValue, as created by encodeBundle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>CBOR value to read from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="classBundle.html" title="Representation of a DTN7 bundle in accordance to RFC9171.">Bundle</a> Read from the Cbor Value, or an empty <a class="el" href="classBundle.html" title="Representation of a DTN7 bundle in accordance to RFC9171.">Bundle</a> if reading was unsuccessful. </dd></dl>

</div>
</div>
<a id="ae5e3f91aee3af75bf5ea5225f95814f0" name="ae5e3f91aee3af75bf5ea5225f95814f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5e3f91aee3af75bf5ea5225f95814f0">&#9670;&#160;</a></span>decodeEidArray()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="structEID.html">EID</a> &gt; decodeEidArray </td>
          <td>(</td>
          <td class="paramtype">CborValue *&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>reads an array of EIDs from a CBOR value, if it contains an array of EIDs in their standard CBOR encoding. Such an array can be created with encodeEidArray. The given CborValue is advanced to the next element after the Array of EIDs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the CborValue to read EIDs from. Must point to an CBOR Array containing EIDs! Will be advanced to next element after the array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a Vector of EIDs, empty if none were decoded </dd></dl>

</div>
</div>
<a id="ab6d1d044de56caec6251027e885bd941" name="ab6d1d044de56caec6251027e885bd941"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6d1d044de56caec6251027e885bd941">&#9670;&#160;</a></span>decodeHashesSet()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::set&lt; size_t &gt; decodeHashesSet </td>
          <td>(</td>
          <td class="paramtype">CborValue *&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>decodes a set of Hashes from CBOR Array pointed to by the given CborValue. Such a CBOR array can be created using encodeHashesSet. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>CBOR value to read from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the set of Hashes encode in the CBOR Array </dd></dl>

</div>
</div>
<a id="a4968f4b81f900f158f9b27c330da8590" name="a4968f4b81f900f158f9b27c330da8590"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4968f4b81f900f158f9b27c330da8590">&#9670;&#160;</a></span>decodeNodeArray()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classNode.html">Node</a> &gt; decodeNodeArray </td>
          <td>(</td>
          <td class="paramtype">CborValue *&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>reads an array of Nodes from a CBOR value, if it contains a CBOR array of byte strings, as created by encodeNodeArray. The Stored nodes are returned in a vector. The given CborValue is advanced to the next element after the Array of Nodes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The CborValue to read Nodes from. Must point to an CBOR Array containing serialized Nodes! Will be advanced to next element after the array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the decoded nodes in a vector, or an empty vector if none were encoded. </dd></dl>

</div>
</div>
<a id="addbe47bad3434e49a9eff95d45eeff30" name="addbe47bad3434e49a9eff95d45eeff30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addbe47bad3434e49a9eff95d45eeff30">&#9670;&#160;</a></span>encodeBundle()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void encodeBundle </td>
          <td>(</td>
          <td class="paramtype">CborEncoder *&#160;</td>
          <td class="paramname"><em>encoder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classBundle.html">Bundle</a> *&#160;</td>
          <td class="paramname"><em>bundle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>encodes the given <a class="el" href="classBundle.html" title="Representation of a DTN7 bundle in accordance to RFC9171.">Bundle</a> into a CBOR Byte String, the byte string is equivalent to the CBOR encoding of the <a class="el" href="classBundle.html" title="Representation of a DTN7 bundle in accordance to RFC9171.">Bundle</a>, as described in RFC9171. Can be decoded using decodeBundle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">encoder</td><td>the encoder onto which the <a class="el" href="classBundle.html" title="Representation of a DTN7 bundle in accordance to RFC9171.">Bundle</a> is to be encoded </td></tr>
    <tr><td class="paramname">bundle</td><td>the <a class="el" href="classBundle.html" title="Representation of a DTN7 bundle in accordance to RFC9171.">Bundle</a> to be encoded </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac260466aacbabdadd5dc2b8c92360b12" name="ac260466aacbabdadd5dc2b8c92360b12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac260466aacbabdadd5dc2b8c92360b12">&#9670;&#160;</a></span>encodeEidArray()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void encodeEidArray </td>
          <td>(</td>
          <td class="paramtype">CborEncoder *&#160;</td>
          <td class="paramname"><em>encoder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structEID.html">EID</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>Eids</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>encodes all EIDs contained in the given vector into an CBOR array on the given CBOR Encoder, the CBOR encoding of the individual EIDs is as described in RFC9171. The resulting array can be decoded with decodeEidArray. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">encoder</td><td>encoder to be used </td></tr>
    <tr><td class="paramname">Eids</td><td>EIDs to be encoded </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adbbe2b2dfcf7d35e10c7a3c9f9620e53" name="adbbe2b2dfcf7d35e10c7a3c9f9620e53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbbe2b2dfcf7d35e10c7a3c9f9620e53">&#9670;&#160;</a></span>encodeHashesSet()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void encodeHashesSet </td>
          <td>(</td>
          <td class="paramtype">CborEncoder *&#160;</td>
          <td class="paramname"><em>encoder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::set&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>hashes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>encodes a set of Hashes into a CBOR Array, can be decoded using decodeHashesSet. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">encoder</td><td>the encoder onto which the hashes are to be written </td></tr>
    <tr><td class="paramname">hashes</td><td>the hashes to encode </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a92ccd75e1f847363ec21ee8ba5ca8fae" name="a92ccd75e1f847363ec21ee8ba5ca8fae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92ccd75e1f847363ec21ee8ba5ca8fae">&#9670;&#160;</a></span>encodeNodeArray()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void encodeNodeArray </td>
          <td>(</td>
          <td class="paramtype">CborEncoder *&#160;</td>
          <td class="paramname"><em>encoder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classNode.html">Node</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>nodes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>encode all Nodes of the given <a class="el" href="classNode.html" title="This class represents a DTN node.">Node</a> Vector into a CBOR array of Byte Strings, the byte strings are equivalent to the CBOR encoding of the node object. The resulting CBOR can be decoded with decodeNodeArray. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">encoder</td><td>the encoder to be used </td></tr>
    <tr><td class="paramname">nodes</td><td>the nodes to encode in a vector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae622e76ceddf80a00f7a43e3dc3cf1da" name="ae622e76ceddf80a00f7a43e3dc3cf1da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae622e76ceddf80a00f7a43e3dc3cf1da">&#9670;&#160;</a></span>stringFromCbor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string stringFromCbor </td>
          <td>(</td>
          <td class="paramtype">CborValue *&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>reads an std::string from a CborValue containing a CBOR Text string. The given CborValue is advanced to the next element after the String </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the CborValue to read string from. Will NOT be advanced to next element after the string, as this leads to decoding errors if the next element is a CBOR primitive type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the String Stored in the CborValue, or a string containing "error" if no string was stored </dd></dl>

</div>
</div>
<a id="a39262bc3dc1bd972a7cbdb5e6c2e08d6" name="a39262bc3dc1bd972a7cbdb5e6c2e08d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39262bc3dc1bd972a7cbdb5e6c2e08d6">&#9670;&#160;</a></span>stringToCbor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void stringToCbor </td>
          <td>(</td>
          <td class="paramtype">CborEncoder *&#160;</td>
          <td class="paramname"><em>encoder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>toEncode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>encodes a given std::string onto a given CBOR Encoder </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">encoder</td><td>CborEncoder to use </td></tr>
    <tr><td class="paramname">toEncode</td><td>string which shall be CBOR encoded </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
