<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>dtn7-esp: InMemoryStorageSerialized Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">dtn7-esp
   </div>
   <div id="projectbrief">An implementation of the Bundle Protocol Version 7 (RFC9171) for ESP32 microcontrollers using the ESP-IDF</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classInMemoryStorageSerialized-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">InMemoryStorageSerialized Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Stores bundles, nodes and bundle IDs in memory. Bundles and nodes are serialized for storage. This reduces the space required to store bundles. The amount of memory which is used for bundle storage is limited indirectly, as a desired amount of heap which shall remain free can be set in menuconfig. If this limit is surpassed by storing another bundle the oldest bundles are removed from storage. How many bundles are removed can be configured in menuconfig. Note: removal is very slow due to some currently unknown problem.  
 <a href="classInMemoryStorageSerialized.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="InMemoryStorage_8hpp_source.html">InMemoryStorage.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for InMemoryStorageSerialized:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classInMemoryStorageSerialized.png" usemap="#InMemoryStorageSerialized_map" alt=""/>
  <map id="InMemoryStorageSerialized_map" name="InMemoryStorageSerialized_map">
<area href="classStorage.html" title="base class for storage implementations, access to derived classes needs to be thread safe!" alt="Storage" shape="rect" coords="0,0,168,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a32867779234f4d50bb33dea6e9c7e742" id="r_a32867779234f4d50bb33dea6e9c7e742"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classInMemoryStorageSerialized.html#a32867779234f4d50bb33dea6e9c7e742">addNode</a> (<a class="el" href="classNode.html">Node</a> node) override</td></tr>
<tr class="memdesc:a32867779234f4d50bb33dea6e9c7e742"><td class="mdescLeft">&#160;</td><td class="mdescRight">adds a node to the known nodes, if it is already present, it is overwritten  <br /></td></tr>
<tr class="separator:a32867779234f4d50bb33dea6e9c7e742"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4f631ba031f5e878987030b2518d547" id="r_ad4f631ba031f5e878987030b2518d547"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classInMemoryStorageSerialized.html#ad4f631ba031f5e878987030b2518d547">removeNode</a> (std::string address) override</td></tr>
<tr class="memdesc:ad4f631ba031f5e878987030b2518d547"><td class="mdescLeft">&#160;</td><td class="mdescRight">removes a node from the list of known nodes  <br /></td></tr>
<tr class="separator:ad4f631ba031f5e878987030b2518d547"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03ed789916abcd568e0950d9261b2d55" id="r_a03ed789916abcd568e0950d9261b2d55"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classNode.html">Node</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classInMemoryStorageSerialized.html#a03ed789916abcd568e0950d9261b2d55">getNode</a> (std::string address) override</td></tr>
<tr class="memdesc:a03ed789916abcd568e0950d9261b2d55"><td class="mdescLeft">&#160;</td><td class="mdescRight">gets a previously stored node object from a given address/identifier  <br /></td></tr>
<tr class="separator:a03ed789916abcd568e0950d9261b2d55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a984c9a2b1899ba0aaaafee6cd02eb6" id="r_a7a984c9a2b1899ba0aaaafee6cd02eb6"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classNode.html">Node</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classInMemoryStorageSerialized.html#a7a984c9a2b1899ba0aaaafee6cd02eb6">getNodes</a> () override</td></tr>
<tr class="memdesc:a7a984c9a2b1899ba0aaaafee6cd02eb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">gets all known nodes  <br /></td></tr>
<tr class="separator:a7a984c9a2b1899ba0aaaafee6cd02eb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8307602c803d757235a1691928904168" id="r_a8307602c803d757235a1691928904168"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classInMemoryStorageSerialized.html#a8307602c803d757235a1691928904168">checkSeen</a> (std::string bundleID) override</td></tr>
<tr class="memdesc:a8307602c803d757235a1691928904168"><td class="mdescLeft">&#160;</td><td class="mdescRight">checks whether a bundleID was seen before  <br /></td></tr>
<tr class="separator:a8307602c803d757235a1691928904168"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6abfa3e5fe0a5be502764122ae21cc84" id="r_a6abfa3e5fe0a5be502764122ae21cc84"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classInMemoryStorageSerialized.html#a6abfa3e5fe0a5be502764122ae21cc84">storeSeen</a> (std::string bundleID) override</td></tr>
<tr class="memdesc:a6abfa3e5fe0a5be502764122ae21cc84"><td class="mdescLeft">&#160;</td><td class="mdescRight">adds a BundleId to the known BundleIDs, if it is not already known, if it is already stored it is overridden  <br /></td></tr>
<tr class="separator:a6abfa3e5fe0a5be502764122ae21cc84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a396cd3378498118d4f9a39abcdc03c03" id="r_a396cd3378498118d4f9a39abcdc03c03"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classInMemoryStorageSerialized.html#a396cd3378498118d4f9a39abcdc03c03">removeBundle</a> (std::string bundleID) override</td></tr>
<tr class="memdesc:a396cd3378498118d4f9a39abcdc03c03"><td class="mdescLeft">&#160;</td><td class="mdescRight">removes a <a class="el" href="classBundle.html" title="Representation of a DTN7 bundle in accordance to RFC9171.">Bundle</a> from storage  <br /></td></tr>
<tr class="separator:a396cd3378498118d4f9a39abcdc03c03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2ff4a3406368690252432b84240b7c2" id="r_ae2ff4a3406368690252432b84240b7c2"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classBundleInfo.html">BundleInfo</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classInMemoryStorageSerialized.html#ae2ff4a3406368690252432b84240b7c2">delayBundle</a> (<a class="el" href="classBundleInfo.html">BundleInfo</a> *bundle) override</td></tr>
<tr class="memdesc:ae2ff4a3406368690252432b84240b7c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">stores a given bundle for later retransmission  <br /></td></tr>
<tr class="separator:ae2ff4a3406368690252432b84240b7c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43eae9f58e824717fdbcc1fd30e208f4" id="r_a43eae9f58e824717fdbcc1fd30e208f4"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classBundleInfo.html">BundleInfo</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classInMemoryStorageSerialized.html#a43eae9f58e824717fdbcc1fd30e208f4">getBundlesRetry</a> () override</td></tr>
<tr class="memdesc:a43eae9f58e824717fdbcc1fd30e208f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns n previously delayed bundles as a vector. The Exact size can be configured in menuconfig. Called repeatedly when retrying bundles. Starts with the oldest batch of bundles. Only returns bundles up until to the point where the last bundle was stored when <a class="el" href="classInMemoryStorageSerialized.html#a6e136fb593a4b1ae283b5eac9a0d8dd4" title="internally stores what the number of bundles was when it was called">beginRetryCycle()</a> was called.  <br /></td></tr>
<tr class="separator:a43eae9f58e824717fdbcc1fd30e208f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a723306736df5102abe4a38075e79cfcd" id="r_a723306736df5102abe4a38075e79cfcd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBundleInfo.html">BundleInfo</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classInMemoryStorageSerialized.html#a723306736df5102abe4a38075e79cfcd">deleteOldest</a> () override</td></tr>
<tr class="memdesc:a723306736df5102abe4a38075e79cfcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">deletes the oldest stored bundle. This function de-serializes all stored bundles and comares all received at times, very slow, maybe due to some programming error  <br /></td></tr>
<tr class="separator:a723306736df5102abe4a38075e79cfcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e136fb593a4b1ae283b5eac9a0d8dd4" id="r_a6e136fb593a4b1ae283b5eac9a0d8dd4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classInMemoryStorageSerialized.html#a6e136fb593a4b1ae283b5eac9a0d8dd4">beginRetryCycle</a> () override</td></tr>
<tr class="memdesc:a6e136fb593a4b1ae283b5eac9a0d8dd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">internally stores what the number of bundles was when it was called  <br /></td></tr>
<tr class="separator:a6e136fb593a4b1ae283b5eac9a0d8dd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a097e94758787d8412b0cb95d22aae9cd" id="r_a097e94758787d8412b0cb95d22aae9cd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classInMemoryStorageSerialized.html#a097e94758787d8412b0cb95d22aae9cd">hasBundlesToRetry</a> () override</td></tr>
<tr class="memdesc:a097e94758787d8412b0cb95d22aae9cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns whether there are still bundles to be returned in this retry  <br /></td></tr>
<tr class="separator:a097e94758787d8412b0cb95d22aae9cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classStorage"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classStorage')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classStorage.html">Storage</a></td></tr>
<tr class="memitem:a80ef6af5e4c9fd4424ae16e808d05291 inherit pub_methods_classStorage" id="r_a80ef6af5e4c9fd4424ae16e808d05291"><td class="memItemLeft" align="right" valign="top">
&#160;</td><td class="memItemRight" valign="bottom"><b>Storage</b> ()</td></tr>
<tr class="memdesc:a80ef6af5e4c9fd4424ae16e808d05291 inherit pub_methods_classStorage"><td class="mdescLeft">&#160;</td><td class="mdescRight">base class representing Some kind of storage for bundles, all methods have to be thread safe! <br /></td></tr>
<tr class="separator:a80ef6af5e4c9fd4424ae16e808d05291 inherit pub_methods_classStorage"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="inherited" name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_attribs_classStorage"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classStorage')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classStorage.html">Storage</a></td></tr>
<tr class="memitem:a8ddb182756d2555f5da52a624ed6d199 inherit pro_attribs_classStorage" id="r_a8ddb182756d2555f5da52a624ed6d199"><td class="memItemLeft" align="right" valign="top">
uint16_t&#160;</td><td class="memItemRight" valign="bottom"><b>bundlesToReturn</b> = 0</td></tr>
<tr class="memdesc:a8ddb182756d2555f5da52a624ed6d199 inherit pro_attribs_classStorage"><td class="mdescLeft">&#160;</td><td class="mdescRight">stores how many bundle still need to be retried <br /></td></tr>
<tr class="separator:a8ddb182756d2555f5da52a624ed6d199 inherit pro_attribs_classStorage"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Stores bundles, nodes and bundle IDs in memory. Bundles and nodes are serialized for storage. This reduces the space required to store bundles. The amount of memory which is used for bundle storage is limited indirectly, as a desired amount of heap which shall remain free can be set in menuconfig. If this limit is surpassed by storing another bundle the oldest bundles are removed from storage. How many bundles are removed can be configured in menuconfig. Note: removal is very slow due to some currently unknown problem. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a32867779234f4d50bb33dea6e9c7e742" name="a32867779234f4d50bb33dea6e9c7e742"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32867779234f4d50bb33dea6e9c7e742">&#9670;&#160;</a></span>addNode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void InMemoryStorageSerialized::addNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classNode.html">Node</a>&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>adds a node to the known nodes, if it is already present, it is overwritten </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>node to store </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classStorage.html#a22ec0f43aed9471349dde5c6e803737e">Storage</a>.</p>

</div>
</div>
<a id="a6e136fb593a4b1ae283b5eac9a0d8dd4" name="a6e136fb593a4b1ae283b5eac9a0d8dd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e136fb593a4b1ae283b5eac9a0d8dd4">&#9670;&#160;</a></span>beginRetryCycle()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void InMemoryStorageSerialized::beginRetryCycle </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>internally stores what the number of bundles was when it was called </p>

<p>Implements <a class="el" href="classStorage.html#a97732a9413649b7d9b9c5fbda81a6469">Storage</a>.</p>

</div>
</div>
<a id="a8307602c803d757235a1691928904168" name="a8307602c803d757235a1691928904168"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8307602c803d757235a1691928904168">&#9670;&#160;</a></span>checkSeen()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool InMemoryStorageSerialized::checkSeen </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>bundleID</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>checks whether a bundleID was seen before </p>
<p>checks whether a bundle with a given ID was seen Before</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bundleID</td><td>std::string containing the BundleID to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether the bundle Id was seen before</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bundleID</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the bundle was seen before </dd></dl>

<p>Implements <a class="el" href="classStorage.html#a18eed947d16a67c6834e46aa4a9fc56a">Storage</a>.</p>

</div>
</div>
<a id="ae2ff4a3406368690252432b84240b7c2" name="ae2ff4a3406368690252432b84240b7c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2ff4a3406368690252432b84240b7c2">&#9670;&#160;</a></span>delayBundle()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classBundleInfo.html">BundleInfo</a> &gt; InMemoryStorageSerialized::delayBundle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classBundleInfo.html">BundleInfo</a> *&#160;</td>
          <td class="paramname"><em>bundle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>stores a given bundle for later retransmission </p>
<p>Stores a bundle. If there is insufficient space, the oldest stored bundle is removed from storage, and returned in a vector.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bundle</td><td>bundle to store </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>if other bundles were removed from storage in order to fit the new one, a vector of the removed bundles is returned</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bundle</td><td>the bundle to be stored </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector containing the bundle which was deleted to make space for the new bundle </dd></dl>

<p>Implements <a class="el" href="classStorage.html#a000fe01eb8642c9233762e54264b7670">Storage</a>.</p>

</div>
</div>
<a id="a723306736df5102abe4a38075e79cfcd" name="a723306736df5102abe4a38075e79cfcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a723306736df5102abe4a38075e79cfcd">&#9670;&#160;</a></span>deleteOldest()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBundleInfo.html">BundleInfo</a> InMemoryStorageSerialized::deleteOldest </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>deletes the oldest stored bundle. This function de-serializes all stored bundles and comares all received at times, very slow, maybe due to some programming error </p>
<dl class="section return"><dt>Returns</dt><dd>the Deleted <a class="el" href="classBundle.html" title="Representation of a DTN7 bundle in accordance to RFC9171.">Bundle</a> </dd></dl>

<p>Implements <a class="el" href="classStorage.html#a1d039278e537d23f7c05b36dc1d75946">Storage</a>.</p>

</div>
</div>
<a id="a43eae9f58e824717fdbcc1fd30e208f4" name="a43eae9f58e824717fdbcc1fd30e208f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43eae9f58e824717fdbcc1fd30e208f4">&#9670;&#160;</a></span>getBundlesRetry()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classBundleInfo.html">BundleInfo</a> &gt; InMemoryStorageSerialized::getBundlesRetry </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns n previously delayed bundles as a vector. The Exact size can be configured in menuconfig. Called repeatedly when retrying bundles. Starts with the oldest batch of bundles. Only returns bundles up until to the point where the last bundle was stored when <a class="el" href="classInMemoryStorageSerialized.html#a6e136fb593a4b1ae283b5eac9a0d8dd4" title="internally stores what the number of bundles was when it was called">beginRetryCycle()</a> was called. </p>

<p>Implements <a class="el" href="classStorage.html#a4230d0d997560216512ec13135f9be26">Storage</a>.</p>

</div>
</div>
<a id="a03ed789916abcd568e0950d9261b2d55" name="a03ed789916abcd568e0950d9261b2d55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03ed789916abcd568e0950d9261b2d55">&#9670;&#160;</a></span>getNode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classNode.html">Node</a> InMemoryStorageSerialized::getNode </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>address</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>gets a previously stored node object from a given address/identifier </p>
<p>gets the node object for a given address, if it was seen before. Otherwise returns an empty node object.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the previously stored node if it exists, otherwise a empty node object</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td>address(unique identifier) to look up </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

<p>Implements <a class="el" href="classStorage.html#a41f8d7c76a6c3256446f89a1d8d8db6f">Storage</a>.</p>

</div>
</div>
<a id="a7a984c9a2b1899ba0aaaafee6cd02eb6" name="a7a984c9a2b1899ba0aaaafee6cd02eb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a984c9a2b1899ba0aaaafee6cd02eb6">&#9670;&#160;</a></span>getNodes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classNode.html">Node</a> &gt; InMemoryStorageSerialized::getNodes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>gets all known nodes </p>
<dl class="section return"><dt>Returns</dt><dd>a vector containing all known nodes </dd></dl>

<p>Implements <a class="el" href="classStorage.html#a6580687d0f0d6fa437ff071a71bb49fc">Storage</a>.</p>

</div>
</div>
<a id="a097e94758787d8412b0cb95d22aae9cd" name="a097e94758787d8412b0cb95d22aae9cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a097e94758787d8412b0cb95d22aae9cd">&#9670;&#160;</a></span>hasBundlesToRetry()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool InMemoryStorageSerialized::hasBundlesToRetry </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns whether there are still bundles to be returned in this retry </p>

<p>Implements <a class="el" href="classStorage.html#adc8cb8985cc11c7da9b199f46cd22eab">Storage</a>.</p>

</div>
</div>
<a id="a396cd3378498118d4f9a39abcdc03c03" name="a396cd3378498118d4f9a39abcdc03c03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a396cd3378498118d4f9a39abcdc03c03">&#9670;&#160;</a></span>removeBundle()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool InMemoryStorageSerialized::removeBundle </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>bundleID</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>removes a <a class="el" href="classBundle.html" title="Representation of a DTN7 bundle in accordance to RFC9171.">Bundle</a> from storage </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bundleID</td><td>BundleId of the bundle to remove </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the bundle was previously stored, otherwise false </dd></dl>

<p>Implements <a class="el" href="classStorage.html#a10d9ac4bdb0bacc7db1299147225ceab">Storage</a>.</p>

</div>
</div>
<a id="ad4f631ba031f5e878987030b2518d547" name="ad4f631ba031f5e878987030b2518d547"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4f631ba031f5e878987030b2518d547">&#9670;&#160;</a></span>removeNode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void InMemoryStorageSerialized::removeNode </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>address</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>removes a node from the list of known nodes </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td></td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classStorage.html#a02f157a69b8fd706cc884e5d8e868e10">Storage</a>.</p>

</div>
</div>
<a id="a6abfa3e5fe0a5be502764122ae21cc84" name="a6abfa3e5fe0a5be502764122ae21cc84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6abfa3e5fe0a5be502764122ae21cc84">&#9670;&#160;</a></span>storeSeen()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void InMemoryStorageSerialized::storeSeen </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>bundleID</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>adds a BundleId to the known BundleIDs, if it is not already known, if it is already stored it is overridden </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bundleID</td><td>bundleId to mark as seen </td></tr>
    <tr><td class="paramname">node</td><td>identifier of the node from which the <a class="el" href="classBundle.html" title="Representation of a DTN7 bundle in accordance to RFC9171.">Bundle</a> was received </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classStorage.html#a51c48f513db9ee772e7210da7d88b638">Storage</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>dtn7-esp/include/Storage/<a class="el" href="InMemoryStorage_8hpp_source.html">InMemoryStorage.hpp</a></li>
<li>dtn7-esp/src/Storage/<b>StorageSerialized.cpp</b></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
